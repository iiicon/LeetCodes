### 题材

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。

### 思路

动态规划则把问题分解成相互依赖的子问题

    // 对于 [2, 0, 0, 4, 5]，能打劫到的最大钱财是7
    expect(rob([2, 0, 0, 4, 5])).toBe(7);

- 如果数组的长度是 1，返回第一项
- 如果数组的长度是 2，返回第一项和第二项的最大值
- 如果数组的长度是 3，返回 `数组长度是2（就是前两项）的值` 和 `第一项 + 最后一项的值` 的最大值
- 如果数组的长度是 4，返回 `前三项的值` 和 `前两项得到的值 + 最后一项的值` 的最大值
- 如果数组的长度是 5，返回 `前四项的值` 和 `前三项得到的值 + 最后一项的值` 的最大值
  ...
- 如果数组的长度为 n，返回 `前（n-1）项的值` 和 `前（n-2）的值 + 最后一项的值` 的最大值
----
    f(0) = array[0]
    f(1) = Math.max(array[0], array[1])
    f(n) = Math.max(f(n-1), array[-1]+f(n-2))

### 问题

动态规划
